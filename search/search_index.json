{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bullethell X Modding and Scripting Guide","text":"<p>Welcome to modding in Bullethell X!</p> <p>This guide will walk you through creating mods, using the scripting interface, and exploring a few advanced techniques.</p> <p>Ready to start modding? Grab the game on Steam and let\u2019s get going!</p>"},{"location":"about/","title":"Pallante meruisse formosos totiens","text":""},{"location":"about/#reperta-longis-contraria-utve","title":"Reperta longis contraria utve","text":""},{"location":"about/#sorbent-referat-cur-cornua","title":"Sorbent referat cur cornua","text":"<p>Lorem markdownum cruore pervia. Carbasa stellamque silva praetenta fugiunt Aeacus sedet quoque fremebundus grave equidem iubet quoque. Esse extendi: omni nomen tu sollicitis habent inmurmurat socia moverat vulnera multifidasque pars in! Mallem agmina diversaque visa.</p>"},{"location":"about/#ingens-intrarant-usus-boves","title":"Ingens intrarant usus boves","text":"<p>Pede aras ianua et freta superest ominibus terris. A pontus tacito citharaque sontes, Parnasia memor illa.</p>"},{"location":"about/#eodem-postis-inde","title":"Eodem postis inde","text":"<p>Is mente: postquam suum. Nec Elide Athin portus timidis, sano, tum pudor, tuli cepi: est non ultima inque blanditur multaque. Tamen temptaretque sequitur, inhaesit nemorum, de iamque laudamus quas rubet Achilli Haemonio.</p> <pre><code>if (key_type_mbr(extranet_plug_ipv - card - cardMultiprocessing)) {\n    metal_lag_computing += dial_file;\n    avatar -= stationOutbox;\n}\nif (banner_newsgroup + configuration + debuggerBoot(4)) {\n    engine_cluster /= memory_intelligence;\n    printerIvr.scrolling(dongle, camelcaseBufferBash);\n}\nmultitasking += 448128;\n</code></pre>"},{"location":"about/#licet-vota-utque-rogis","title":"Licet vota utque rogis","text":""},{"location":"about/#mihi-densissima-procul","title":"Mihi densissima procul","text":"<p>Pars enim oraque flammis Pelasga ponti invidiae undique animo, progenies satis et heros. Hanc flos quicquam, tempora flevit usus illic ne semivir extulit sit, stamine <code>fiber_wep_pretest</code> inpedit nymphis?</p>"},{"location":"about/#modo-desiderat-adspicit-quaeque","title":"Modo desiderat adspicit quaeque","text":"<p>Chlamydem adversa et agmine, forma dea, sinus nisi tela vetantis Thaumantias publica et Scylla, exilio natusque? Fidem contigerant insuper obscenis Achille. Sed tuta terras, vel serta detque signum in, caeruleo. Saxo is stagna invita. Plura venis viget, cornua, prior, lacunabant quod.</p>"},{"location":"about/#humum-te-arma-sagax","title":"Humum te arma sagax","text":"<p>Et maioris omnia, infans? Aera quam sororia Peleus, cum gente puer coniunx iuvat, vittam.</p> <p>Ministro tantum manusque phocae nunc <code>newline</code> ferrum propiora dominus sternitque vocat; illud plena unumque plumas de pater exstante genus. Intremuere Turnus sit omnes naufraga Bubastis rex Philomela posita herbas Minos, sed.</p>"},{"location":"async/","title":"AsyncFunction","text":"<p><code>AsyncFunction</code> is almost the same as <code>Function</code>. They both run a function defined by their names for their entity.</p> <p>The difference is <code>AsyncFunction</code> is scheduled to run in a thread pool, multiple instances of it run in parallel so it is generally much faster (about 4x faster on 10 threads) than Function.</p> <p>The function however has many requirements to prevent race conditions:</p> <ul> <li>It can NOT create or destroy any entity or component, EVER!</li> <li>In general, it can only query other's components if other does NOT have an AsyncFunction (unless programmer can guarantee that component is not modified during their async function calls)!</li> <li>In general, it can NOT update other's components (unless programmer can guarantees no 2 entities modify the same other entity, which is possible e.g. there is a 1-1 relationship)!</li> <li>It can query entities.</li> <li>In general, it can query and update self.</li> </ul> <p>If any limitations are breached, there can be race conditions, memory can be corrupted and there can be undefined behavior, in the worst case the game crashes.</p> <p>Note</p> <p>AsyncFunction is designed for e.g. custom bullet trajectories; there are many instances of such bullets, they only need to query/update self.</p>"},{"location":"async/#example-exploding-bullet","title":"Example: Exploding bullet","text":"<p><code>AsyncFunction</code> of a bullet that stops moving after X seconds, and splits into N sub-bullets in a circular pattern.</p>"},{"location":"async/#approach-1","title":"Approach 1","text":"<p>Entity is created with Metadata, which initially contains variables <code>X</code> and <code>N</code>, as well as an <code>triggered</code> flag set to 0.</p> <p>Entity has an <code>AsyncFunction</code> and a <code>Function</code> component.</p> <p><code>AsyncFunction</code> does the following: After <code>X</code> seconds, set flag <code>triggered</code> to <code>1</code>.</p> <p><code>Function</code> does the following: if <code>triggered</code> is set to 1,</p> <ul> <li>remove the <code>AsyncFunction</code> component,</li> <li>remove the <code>Function</code> component,</li> <li>and fire <code>N</code> bullets.</li> </ul>"},{"location":"async/#approach-2","title":"Approach 2","text":"<p>Entity is created the same way as in approach 1, except <code>Function</code>'s <code>name</code> is initially <code>\"\"</code> (empty string).</p> <p><code>AsyncFunction</code> does the following: After <code>X</code> seconds, update <code>Function</code>'s <code>name</code> to a proper function name.</p> <p>That <code>Function</code> then does the following:</p> <ul> <li>remove the <code>AsyncFunction</code> component,</li> <li>removes the <code>Function</code> component,</li> <li>and fire <code>N</code> bullets.</li> </ul> <p>Remark</p> <p>Notice in both approaches, the AsyncFunction never creates new entities (e.g.firing bullets) or new components (a new Function). It updates existing fields or metadata, and lets a regular Function takes care of the rest.</p>"},{"location":"async/#conclusion","title":"Conclusion","text":"<p>Any Function that meets these requirements can be changed to AsyncFunction; the game should behave the exact same and get the performance improvements for free.</p>"},{"location":"engine_interface/","title":"The Engine Interface","text":"<p>All game functionality is accessed through the engine interface.</p>"},{"location":"engine_interface/#enginecreateentity","title":"Engine.createEntity","text":"createEntity<pre><code>--- @return integer eid entity ID of the created entity\nEngine.createEntity = function()\n</code></pre> Sample Usage<pre><code>local eid = Engine.createEntity()\n</code></pre>"},{"location":"engine_interface/#enginecreatecomponent","title":"Engine.createComponent","text":"createComponent<pre><code>--- @param eid integer entity ID\n--- @param t string component type\n--- @param c table component data, fields must match definition in struct.dsl\nEngine.createComponent = function(eid, t, c)\n</code></pre> Sample Usage<pre><code>Engine.createComponent(eid, \"Health\", {hp = 4, maxHP = 7}) -- OK\nEngine.createComponent(eid, \"Health\", {hp = 5})            -- BAD (1)\nEngine.createComponent(eid, \"Health\",\n    {hp = 4, maxHP = 7, somethingElse = \"hello\"})          -- ??  (2)\n</code></pre> <ol> <li><code>maxHP</code> is not defined!</li> <li>OK, but <code>somethingElse</code> does nothing.</li> </ol> <p>Important!</p> <p>When creating a component, all of its fields must be defined! To see which fields a component has, see <code>structs.dsl</code>!</p>"},{"location":"engine_interface/#engineentities","title":"Engine.entities","text":"entities<pre><code>--- @param ... string component types\n--- @return table\nEngine.entities = function(...)\n</code></pre> Sample Usage<pre><code>local es = Engine.entities(\"Health\", \"Enemy\")      --     (1)\nlocal es = Engine.entities(\"Position\")             --     (2)\nlocal es = Engine.entities(\"NonExistentGibberish\") -- BAD (3)\n</code></pre> <ol> <li>Get all the entities that have a <code>Health</code> and <code>Enemy</code> component.</li> <li>Get all the entities that have a <code>Position</code> component.</li> <li>Can NOT get components that don't exist!</li> </ol> <p>Tip</p> <p>You can specify any number of components! This function will return a list of entities that have all of the components. If no such entity exists, an empty list is returned.</p>"},{"location":"engine_interface/#enginecomponent","title":"Engine.component","text":"component<pre><code>--- @param eid integer entity ID\n--- @param t string component type\n--- @return table | nil component data or nil if not found\nEngine.component = function(eid, t)\n</code></pre> Sample Usage<pre><code>local es = Engine.entities(\"Health\", \"Enemy\")\nfor i = 1, #es do\n    local eid = es[i]\n    local health = Engine.component(eid, \"Health\") -- OK (1)\nend\n</code></pre> <ol> <li>Guaranteed to exist! (Because we queried entities with Health)</li> </ol> <p>Tip</p> <p>If you call <code>component()</code> immediately on an entity from a list returned by <code>entities()</code> (where the component is one of the arguments), the requested component is guaranteed to exist.</p> <p>Otherwise, you can use <code>component()</code> to test whether a component exists by checking the result being <code>nil</code>.</p>"},{"location":"engine_interface/#engineupdate","title":"Engine.update","text":"update<pre><code>--- @param eid integer entity ID\n--- @param t string component type\n--- @param c table component data, fields must match definition in struct.dsl\nEngine.update = function(eid, t, c)\n</code></pre> Sample Usage<pre><code>local es = Engine.entities(\"Health\", \"Enemy\")\nfor i = 1, #es do\n    local eid = es[i]\n    local health = Engine.component(eid, \"Health\")\n    health.maxHP = 1\n    Engine.update(eid, \"Health\", health)               -- OK  (1)\n\n    Engine.update(eid, \"Health\", {hp = 1, maxHP = 10}) -- OK  (2)\n    Engine.update(eid, \"Health\", {hp = 1})             -- BAD (3)\nend\n</code></pre> <ol> <li>Every enemy has <code>maxHP</code> of 1 now.</li> <li>Every enemy has <code>1/10</code> health now.</li> <li><code>maxHP</code> is not defined.</li> </ol> <p>Important!</p> <p>Similar to <code>createComponent()</code>, all of its fields must be defined!</p>"},{"location":"engine_interface/#enginedestroycomponent","title":"Engine.destroyComponent","text":"destroyComponent<pre><code>--- @param eid integer entity ID\n--- @param t string component type\nEngine.destroyComponent = function(eid, t)\n</code></pre> Sample Usage<pre><code>local es = Engine.entities(\"IFrame\", \"Enemy\")\nfor i = 1, #es do\n    local eid = es[i]\n    Engine.destroyComponent(eid, \"IFrame\")       -- OK  (1)\n    Engine.destroyComponent(eid, \"IFrame\")       -- ??  (2)\n    Engine.destroyComponent(eid, \"DoesNotExist\") -- BAD (3)\nend\n</code></pre> <ol> <li>Destroy all enemy <code>IFrames</code>.</li> <li><code>IFrames</code> is already destroyed, does nothing.</li> <li><code>DoesNotExist</code> is not a struct, game will crash.</li> </ol>"},{"location":"engine_interface/#enginedestroyentity","title":"Engine.destroyEntity","text":"destroyEntity<pre><code>--- @param eid integer entity ID\nEngine.destroyEntity = function(eid)\n</code></pre> Sample Usage<pre><code>local es = Engine.entities(\"Enemy\")\nfor i = 1, #es do\n    local eid = es[i]\n    Engine.destroyEntity(eid)                -- OK (1)\n    Engine.destroyEntity(eid)                -- ?? (2)\n    Engine.destroyComponent(eid, \"Enemy\")    -- ?? (3)\n    Engine.createComponent(eid, \"Enemy\", {}) -- ?? (4)\nend\n</code></pre> <ol> <li>Destroy all enemies (and associated components)!</li> <li>Does nothing, the first <code>destroyEntity()</code> invalidates <code>eid</code>.</li> <li>Does nothing, <code>eid</code> is already invalid.</li> <li>Does nothing, <code>eid</code> is already invalid.</li> </ol>"},{"location":"first_boss/","title":"Creating a Boss","text":"<p>In this section, we\u2019ll create a simple boss, load it into the game, make a small change, and then hot-reload it to see the results.</p>"},{"location":"first_boss/#step-1-create-your-mod-folder","title":"Step 1: Create Your Mod Folder","text":"<p>Create a new folder inside <code>bx/mods</code>. This is where all your files will live. For example:</p> <pre><code>bx/mods/my_mod\n</code></pre> <p>Important</p> <p>Folder names can NOT have spaces (or most special characters). We recommend sticking to names using only letters, numbers, and underscore.</p>"},{"location":"first_boss/#step-2-write-your-first-boss-script","title":"Step 2: Write Your First Boss Script","text":"<p>Create a new Lua script, e.g.</p> <pre><code>bx/mods/my_mod/new_boss.lua\n</code></pre> <p>Paste the following code into the file:</p> bx/mods/my_mod/new_boss.lua<pre><code>require(\"bx.scripts.engine\")\nrequire(\"bx.scripts.utils\")\nrequire(\"bx.scripts.helpers\")\n\nlocal function attack(eid, meta)\n    local speed = fp(0.45)\n    local v = meta.rot * Vec2.new(0, speed)\n\n    Helper.fireStandardBulletBoss({\n        firedBy = eid,\n        position = Engine.component(eid, \"Position\").position,\n        velocity = v * speed,\n        radius = fp(0.015),\n    })\nend\n\nlocal function update(eid)\n    if Engine.component(eid, \"BossEntrance\") then\n        return\n    end\n    local health = Engine.component(eid, \"Health\")\n    if not health or health.hp &lt;= 0 then\n        return\n    end\n\n    local meta = Engine.component(eid, \"Meta\").meta\n\n    if not meta.attackTime then\n        meta.attackTime = fp(0)\n    end\n    if not meta.rot then\n        meta.rot = Mat2.new(1)\n    end\n    meta.attackTime = meta.attackTime + Engine.dt\n    local theta = fp(Engine.dt * fp(1.5))\n    meta.rot = Mat2.rotate(theta) * meta.rot\n    if meta.attackTime &gt;= meta.attackCD then\n        meta.attackTime = fp(0)\n        attack(eid, meta)\n    end\n\n    if not meta.t then\n        meta.t = fp(0)\n    end\n    meta.t = meta.t - Engine.dt * fp(2.1)\n\n    Engine.update(eid, \"Meta\", { meta = meta })\nend\n\nlocal function create(difficulty)\n    local e = Helper.createStandardBoss({ difficulty = difficulty })\n    local attackCD = fpmath.clamp(fp(0.2) - fp(0.01) * difficulty, fp(0.1), fp(0.2))\n    Engine.createComponent(e, \"Meta\", { meta = { attackCD = attackCD } })\n    return e\nend\n\nreturn {\n    boss = {\n        name = \"New Boss\",\n        create = create,\n        update = update,\n    }\n}\n</code></pre>"},{"location":"first_boss/#step-3-load-your-mod-in-game","title":"Step 3: Load Your Mod In-Game","text":"<ol> <li>Launch the game.</li> <li>Open Settings and make sure:</li> <li>Local Mods are ENABLED</li> <li>Steam Workshop Mods are DISABLED</li> <li>Start a singleplayer game. You should see your new boss performing its basic attack pattern.</li> </ol>"},{"location":"first_boss/#step-4-make-a-live-change","title":"Step 4: Make a Live Change","text":"<p>Open <code>new_boss.lua</code> again (you can do this while the game is running) and edit line 6:</p> bx/mods/my_mod/new_boss.lua<pre><code>- local speed = fp(0.45)\n+ local speed = fp(0.75)\n</code></pre>"},{"location":"first_boss/#step-5-hot-reload-your-mod","title":"Step 5: Hot Reload Your Mod","text":"<p>Switch back to the game and press F5. Your boss will now fire bullets at a faster speed.</p> <p>Success</p> <p>Congratulations! You\u2019ve just completed the basic Bullethell X modding workflow.</p>"},{"location":"making_tweaks/","title":"Customizing the Boss","text":"<p>Experiment with a few more tweaks to see how they change the gameplay! Here are some ideas to get you started...</p>"},{"location":"making_tweaks/#firing-angle","title":"Firing Angle","text":"bx/mods/my_mod/new_boss.lua<pre><code>-   local theta = fp(Engine.dt * fp(1.5))\n+   local theta = fp(Engine.dt * fp(25))\n</code></pre>"},{"location":"making_tweaks/#bullet-radius","title":"Bullet Radius","text":"bx/mods/my_mod/new_boss.lua<pre><code>    Helper.fireStandardBulletBoss({\n        firedBy = eid,\n        position = Engine.component(eid, \"Position\").position,\n        velocity = v * speed,\n-       radius = fp(0.015),\n+       radius = fp(0.005),\n    })\n</code></pre>"},{"location":"making_tweaks/#attack-speed","title":"Attack Speed","text":"bx/mods/my_mod/new_boss.lua<pre><code>-   meta.attackTime = meta.attackTime + Engine.dt\n+   meta.attackTime = meta.attackTime + Engine.dt * 5\n</code></pre>"},{"location":"making_tweaks/#multishot","title":"Multishot","text":"bx/mods/my_mod/new_boss.lua<pre><code>local function attack(eid, meta)\n    local speed = fp(0.75)\n    local v = meta.rot * Vec2.new(0, speed)\n+   local n = 5\n+   local rot = Mat2.rotate(fpmath.pi * fp(2) / fp(5))\n+   for _ = 1, n do\n+       v = rot * v\n        Helper.fireStandardBulletBoss({\n            firedBy = eid,\n            position = Engine.component(eid, \"Position\").position,\n            velocity = v * speed,\n            radius = fp(0.015),\n        })\n+   end\nend\n</code></pre>"},{"location":"making_tweaks/#next-steps","title":"Next Steps","text":"<p>Challenge</p> <p>Can you make more changes to create a truly unique attack pattern?</p> <p>Once you're happy with your customization of the first boss, let's go upload this mod onto Steam as a Workshop Item!</p> <p>You can choose to to keep it private!</p>"},{"location":"publishing/","title":"Publishing the Mod","text":""},{"location":"publishing/#steam-workshop-legal-agreement","title":"Steam Workshop Legal Agreement","text":"<p>By submitting items, you agree to the workshop terms of service.</p>"},{"location":"publishing/#in-game-uploader","title":"In-game uploader","text":"<ul> <li> <p>Open the in-game Local Mods menu.</p> </li> <li> <p>Browse the menu and find the mod you just created. Hit Enter.</p> </li> </ul> <p>Note</p> <p>The default display name of the mod is the name of the folder! If you wish to edit the display name, you may do so via Steam's interface after the mod is uploaded.</p> <ul> <li>If you have not yet accpeted the agreement, there is an option to do so now (it'll open up the Steam overlay).</li> <li> <p>Select \"Create Steam Item\", hit Enter!</p> </li> <li> <p>The upload process should begin now, note this can take a few seconds.</p> </li> <li> <p>If this is successful, the menu item should now say \"Update Steam Item\" and a Steam page should open up allowing you to view your mod and edit its details (edit the name, description, upload a preview image, etc.).</p> </li> </ul> <p>Success</p> <p>Congratulations! Your item is now uploaded to Steam.</p>"},{"location":"publishing/#visibility","title":"Visibility","text":"<p>Note that when the mod is first created and uploaded, its visibility is default to private!</p> <p>Once you're ready, you can use Steam's interface to change its visibility.</p> <p>By making it public, players can subscribe to your mod on the Steam Workshop and enjoy it directly in their game.</p>"},{"location":"publishing/#updating-mod-content","title":"Updating Mod Content","text":"<p>If you make changes to your mod, simply select \"Update Steam Item\" and hit Enter.</p>"},{"location":"scripting_basics/","title":"Entity Component System","text":"<p>Bullethell X is built around three concepts:</p> <ul> <li>Entities and Components which make up the game state, and</li> <li>Systems, which define the game logic.</li> </ul>"},{"location":"scripting_basics/#entities","title":"Entities","text":"<p>Entities are simply unique IDs. They don\u2019t contain any data by themselves, but they can have components attached. Each entity can only have one instance of each component type. For example, an entity cannot have two Health components.</p> <pre><code>Engine.createComponent(eid, \"Health\", {hp = 5, maxHP = 5}) -- OK (1)\nEngine.createComponent(eid, \"Health\", {hp = 3, maxHP = 5}) -- ?? (2)\nEngine.destroyComponent(eid, \"Health\")                     -- OK (3) \nEngine.createComponent(eid, \"Health\", {hp = 3, maxHP = 5}) -- OK (4)\n</code></pre> <ol> <li>health is 5/5.</li> <li>Does nothing (already has a Health component).</li> <li>Removes the Health component.</li> <li>Health is now 3/5.</li> </ol>"},{"location":"scripting_basics/#components","title":"Components","text":"<p>Components are structs that hold data. For example, the Health component stores two fields: <code>hp</code> and <code>maxHP</code>. Most component definitions can be found in <code>structs.dsl</code>.</p> structs.dsl<pre><code>struct Health {\n    int hp;\n    int maxHP;\n};\n</code></pre>"},{"location":"scripting_basics/#systems","title":"Systems","text":"<p>Systems define the game logic. They run every frame and describe how components interact with each other.</p> <p>Examples:</p> <ul> <li> <p>A <code>Health</code> component\u2019s <code>hp</code> can never exceed its <code>maxHP</code>.</p> </li> <li> <p>If an entity has both <code>Position</code> and <code>Velocity</code>, its <code>position</code> is updated: <code>Position</code> is offset by <code>Velocity * deltaTime</code>.</p> </li> <li> <p>If an entity has <code>Position</code>, <code>Radius</code>, and <code>Health</code>, check for collisions against entities with <code>Position</code>, <code>Radius</code>, and <code>Bullet</code>. If they overlap, subtract the bullet\u2019s damage from <code>Health</code>. If <code>hp &lt;= 0</code>, destroy the entity.</p> </li> </ul>"},{"location":"scripting_basics/#sample-implementation-clamping-health","title":"Sample Implementation: Clamping Health","text":"<pre><code>local es = Engine.entities(\"Health\")               -- (1)\nfor i = 1, #es do                                  -- (2)\n    local eid = es[i]\n    local health = Engine.component(eid, \"Health\") -- (3)\n    if health.hp &gt; health.maxHP then               -- (4)\n        health.hp = health.maxHP\n        Engine.update(eid, \"Health\", health)       -- (5)\n    end\nend\n</code></pre> <ol> <li>Find all entities with Health component</li> <li>Iterate through them</li> <li>Get each entity's Health component</li> <li>Ensure <code>hp</code> can NOT exceed <code>maxHP</code></li> <li>Apply the updated value</li> </ol>"},{"location":"special_structs/","title":"Special Structs","text":""},{"location":"special_structs/#function","title":"Function","text":"<pre><code>struct Function {\n    string name;\n};\n</code></pre> <p><code>Function</code> is a simple defined struct, however the <code>name</code> field is required to be a global function in Lua! This function must have exactly 1 parameter that is the entity ID which the function acts on.</p>"},{"location":"special_structs/#example","title":"Example","text":"<pre><code>function BulletMovement(bullet_eid)\n-- ...\nend\n\nfunction SomeGlobalFunction()\n-- ...\nend\n\nlocal function justALocalFunction(bullet_eid)\n-- ...\nend\n\n-- ...\nEngine.createComponent(eid, \"Function\", {name=\"BulletMovement\"})     -- OK  (1)\nEngine.createComponent(eid, \"Function\", {name=\"SomeGlobalFunction\"}) -- BAD (2)\nEngine.createComponent(eid, \"Function\", {name=\"justALocalFunction\"}) -- BAD (3)\nEngine.createComponent(eid, \"Function\", {name=\"DreamFunction\"})      -- BAD (4)\n\n-- Suppose DreamFunction is in another file called dream.lua\nrequire(\"bx.scripts.dream\")\nEngine.createComponent(eid, \"Function\", {name=\"DreamFunction\"})      -- OK  (5)\n</code></pre> <ol> <li><code>BulletMovement</code> will be called on <code>eid</code>.</li> <li>But <code>SomeGlobalFunction</code> will still be called...</li> <li><code>justALocalFunction</code> is not accessible, game will crash.</li> <li><code>DreamFunction</code> does not exist, game will crash.</li> <li>Global functions in other files are accessible as long as they're loaded.</li> </ol> <p>Important</p> <p><code>Function</code> is designed for entities that have truly unique behaviors and are small in number, e.g. bosses and players.</p> <p>Running a custom script on a large number entities is slow, even if the function is simple. If you attach <code>Function</code> to bullets and there is a massive number of bullets, the game will most likely lag.</p>"},{"location":"special_structs/#metadata","title":"Metadata","text":"<p>You might be wondering - what if these functions need extra parameters to customize their behavior? That\u2019s exactly what <code>Metadata</code> is for.</p> <p><code>Metadata</code> is a special component that is not defined in <code>structs.dsl</code>! This means they don't use standard Engine APIs. Instead, they have</p> <pre><code>--- @param eid integer entity ID\n--- @param t table metadata\nEngine.createMetadata = function(eid, t)\n\n--- @param eid integer entity ID\nEngine.metadata = function(eid)\n\n--- @param eid integer entity ID\n--- @param t table metadata\nEngine.updateMetadata = function(eid, t)\n\n--- @param eid integer entity ID\nEngine.destroyMetadata = function(eid)\n</code></pre> Sample Usage<pre><code>-- during initialize\n    Engine.createMetadata(e, { attackCD = 0.2 })            -- (1)\n\n-- during update\n    local meta = Engine.metadata(eid)                       -- (2)\n    if not meta.attackTime then meta.attackTime = fp(0) end -- (3)\n    meta.attackTime = meta.attackTime + Engine.dt           -- (4)\n    if meta.attackTime &gt;= meta.attackCD then                -- (5)\n        attack(eid)                                         -- (6)\n        meta.attackTime = fp(0)                             -- (7)\n    end\n    Engine.updateMetadata(eid, meta)                        -- (8)\n</code></pre> <ol> <li>Set attack cooldown to 0.2 seconds</li> <li>Access the metadata</li> <li>Create an attack timer if we don't have one</li> <li>Update the attack timer by delta time</li> <li>Every 0.2 (attack cooldown) seconds</li> <li>Do an attack</li> <li>And reset the timer</li> <li>Update metadata, because attack timer value has changed</li> </ol> <p>Info</p> <p>Together with Function, they are used to achieve arbitrary logic on specific entities! This is the single most scriptable and powerful component of Bullethell X's modding system.</p> <p>Info</p> <p>Metadata currently supports up to 64 fields. Each Metadata instance is 12.8 KB, making it the largest struct in the game. If there are 10,000 entities with Metadata, the memory footprint is 128 MB.</p>"},{"location":"special_structs/#ad-hoc","title":"Ad-hoc","text":""},{"location":"special_structs/#trail","title":"Trail","text":"<p>Most bullets benefit from a trail visual component, to create this component manually, use the <code>Engine.createTrail</code> function:</p> <pre><code>-- Create a trail visual\n--- @param eid integer\n--- @param detail integer\n--- @param opacity number\n--- @param widthScale number | nil if nil, default to 1\n--- @param cd number | nil if nil, use Engine.dt\nEngine.createTrail = function(eid, detail, opacity, widthScale, cd)\n</code></pre> Sample Usage in Helper.fireStandardBulletBoss<pre><code>local bulletEid = Engine.createEntity()\nEngine.createComponent(bulletEid, \"Color\", ... )\nEngine.createComponent(bulletEid, \"Position\", ... )\nEngine.createComponent(bulletEid, \"Radius\", ... )\nEngine.createComponent(bulletEid, \"Velocity\", ... )\nEngine.createComponent(bulletEid, \"Graphic\", ... )\nEngine.createComponent(bulletEid, \"Circle\", {})\nEngine.createComponent(bulletEid, \"Bullet\", {\n    damage = fp(1),\n    firedBy = config.firedBy,\n})\nEngine.createComponent(bulletEid, \"FactionEnemy\", {})\nEngine.createTrail(bulletEid, 8, 0.5, 1, Engine.dt * 2)\nreturn bulletEid\n</code></pre> <p>Important</p> <p><code>detail</code> is at most <code>8</code> and at least <code>1</code>!</p> <p>Info</p> <p>Trail has no accessible/modifiable data! It is merely a visual effect.</p>"},{"location":"structs/","title":"Struct Definitions","text":"<p>You\u2019ll find all struct definitions in <code>structs.dsl</code>. These types are fixed: scripts can\u2019t change their layout or add new structs.</p> <p>Some examples:</p> #1#2#3 structs.dsl<pre><code>struct Radius {\n    sf r;\n};\n\nstruct Position {\n    vec2 position;\n};\n\nstruct Velocity {\n    vec2 v;\n};\n</code></pre> structs.dsl<pre><code>struct Bullet {\n    sf damage;\n    eid firedBy;\n};\n\nstruct Graphic {\n    sf layer;\n    string texture;\n};\n</code></pre> structs.dsl<pre><code>struct PlayerInput {\n    int frame;\n    int playerIdx;\n    vec2 movement;\n    int ping;\n};\n</code></pre>"},{"location":"structs/#struct-fields","title":"Struct Fields","text":"<p>Structs can contain fields of the following types:</p> Type Name Description Technical Details <code>int</code> Integer 64-bit signed <code>sf</code> Decimal number Interally a fixed point number with 6 digits of precision <code>eid</code> Entity ID 64-bit signed integer <code>eids</code> List of Entity ID Lua table of 64-bit signed integers <code>string</code> String At most 64 characters <code>vec2</code> 2D vector Internal data is decimal numbers <code>vec3</code> 3D vector Internal data is decimal numbers <code>vec4</code> 4D vector Internal data is decimal numbers <code>mat2</code> 2x2 matrix Internal data is decimal numbers <code>mat3</code> 3x3 matrix Internal data is decimal numbers <code>mat4</code> 4x4 matrix Internal data is decimal numbers"},{"location":"workflow/","title":"Modding Workflow","text":""},{"location":"workflow/#mod-locations","title":"Mod Locations","text":"<p>Bullethell X loads mods from two sources:</p> <ol> <li>Steam Workshop \u2013 for published mods.</li> <li>Local Mods \u2013 located in <code>bx/mods</code>. This is where you\u2019ll be working during development.</li> </ol> <p>To get started, place your mod files in the <code>bx/mods</code> folder, and the game will automatically detect them.</p>"},{"location":"workflow/#enabling-local-mods","title":"Enabling Local Mods","text":"<ul> <li> <p>Open the in-game Settings menu.</p> </li> <li> <p>Ensure Local Mods are enabled.</p> </li> <li> <p>(Optional) Disable Steam Workshop mods while developing, so they don\u2019t interfere with your work.</p> </li> </ul>"},{"location":"workflow/#publishing-your-mod","title":"Publishing Your Mod","text":"<p>Once your mod is ready, simply use the in-game uploader!</p> <p>After publishing, players can subscribe to your mod on the Steam Workshop and enjoy it directly in their game.</p>"}]}